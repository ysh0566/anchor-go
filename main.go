package main

import (
	"container/list"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/fatih/color"
	"github.com/mr-tron/base58"
	"github.com/spf13/cobra"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

func main() {
	rootCmd := cobra.Command{
		Use:  "anchor-go [path to idl]",
		Args: cobra.ExactArgs(1),
	}
	packageName := rootCmd.Flags().String("package", "generated", "package name for generated code")
	keepComment := rootCmd.Flags().Bool("comment", true, "keep comments in generated code")
	decodeStruct := rootCmd.Flags().Bool("decode", true, "generate decode method for struct")
	instructions := rootCmd.Flags().Bool("instructions", true, "generate instructions")
	outputDir := rootCmd.Flags().String("output", "", "output directory for generated code")
	rootCmd.RunE = func(cmd *cobra.Command, args []string) error {
		filename := args[0]
		data, err := os.ReadFile(filename)
		if err != nil {
			return fmt.Errorf("read file failed: %v", err)
		}
		var idl IDL
		if err := json.Unmarshal(data, &idl); err != nil {
			return fmt.Errorf("unmarshal idl failed: %v", err)
		}
		src, err := generate(&idl, *packageName, *keepComment, *decodeStruct, *instructions)
		if err != nil {
			return err
		}

		return writeToFile(filename, *outputDir, src)
	}
	if err := rootCmd.Execute(); err != nil {
		_, _ = fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func generate(idl *IDL,
	packageName string, keepComment bool,
	decodeStruct bool, instructions bool,
) (string, error) {
	idl.Normalize() // normalize idl

	f := jen.NewFile(packageName)
	f.PackageComment("Code generated by anchor-go. DO NOT EDIT.")
	f.ImportName("github.com/gagliardetto/solana-go", "solana")
	f.ImportName("github.com/gagliardetto/solana-go/rpc", "rpc")
	f.ImportAlias("github.com/gagliardetto/binary", "bin")
	f.ImportName("math/big", "big")

	programIdName := snakeToCamel(idl.Metadata.Name) + "ProgramID"
	f.Var().Id(programIdName).
		Op("=").
		Qual("github.com/gagliardetto/solana-go", "MustPublicKeyFromBase58").Call(jen.Lit(idl.Address.String()))

	if instructions {
		if err := generateInstructions(idl, f, keepComment); err != nil {
			return "", err
		}
	}

	acctTypes := idl.Types[:]
	for _, acct := range idl.Accounts {
		if acct.Type.Kind != "" {
			acctTypes = append(acctTypes, struct {
				Name string `json:"name"`
				Type Type   `json:"type"`
			}{Name: acct.Name, Type: acct.Type})
		}
	}
	for _, t := range acctTypes {
		if t.Name == "" {
			continue
		}

		if t.Type.Kind == "enum" {
			f.Add(jen.Type().Id("Side").Qual("github.com/gagliardetto/binary", "BorshEnum"))
			enums := make([]jen.Code, 0)
			for _, enum := range t.Type.Variants {
				enums = append(enums, jen.Id(fmt.Sprintf("%s%s", t.Name, enum.Name)))
			}
			enums[0] = enums[0].(*jen.Statement).Id("Side").Op("=").Id("iota")
			f.Add(jen.Const().Defs(enums...))
			continue
		}

		if t.Type.Kind != "struct" {
			color.Cyan("type %s is not a struct, skipping", t.Name)
			continue
		}

		// generate struct
		fmt.Printf("generate struct for account %s\n", color.BlueString(t.Name))
		goFields := make([]jen.Code, 0)
		includeUnsupportedFields := false
		for _, field := range t.Type.Fields {
			goType := field.Type.GoType()
			if goType == nil {
				color.Cyan("field %s is not supported, skipping", field.Name)
				includeUnsupportedFields = true
				break
			}

			var goField *jen.Statement
			if len(field.Docs) > 0 && keepComment {
				goField = jen.Comment(strings.Join(field.Docs, "\n")).Line().Id(snakeToCamel(field.Name))
			} else {
				goField = jen.Id(snakeToCamel(field.Name))
			}
			goField.Add(goType)
			if field.Type.Option {
				goField = goField.Tag(map[string]string{"bin": "optional"})
			}
			goFields = append(goFields, goField)
		}
		if includeUnsupportedFields {
			continue
		}
		s := jen.Type().Id(t.Name).Struct(goFields...)
		f.Add(s)

		hasDiscriminator := false
		// generate discriminator method
		for _, acct := range idl.Accounts {
			if acct.Name != t.Name {
				continue
			}
			hasDiscriminator = true
			// func: Discriminator
			f.Add(generateDiscriminator(t.Name, acct.Discriminator).Line())
			break
		}

		// generate discriminator method
		for _, acct := range idl.Events {
			if acct.Name != t.Name {
				continue
			}
			hasDiscriminator = true
			// func: Discriminator
			f.Add(generateDiscriminator(t.Name, acct.Discriminator).Line())
			break
		}
		if !hasDiscriminator {
			f.Add(generateDiscriminator(t.Name, nil).Line()) // add empty discriminator
		}

		// generate decode method
		if decodeStruct {
			decodeFunc := jen.
				Func().
				Id("Decode"+t.Name).
				Params(
					jen.Id("resp").Op("*").Qual("github.com/gagliardetto/solana-go/rpc", "GetAccountInfoResult"),
				).
				Params(jen.Op("*").Id(t.Name), jen.Error()).
				Block(
					jen.Var().Id("m").Id(t.Name),
					jen.Id("data").Op(":=").Id("resp").Dot("GetBinary").Call(),
					jen.If(jen.Len(jen.Id("data")).Op("<").Len(jen.Id("m").Dot("Discriminator").Call())).Block(
						jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(jen.Lit("invalid response data"))),
					),
					jen.Id("discriminator").Op(":=").Id("data").Index(jen.Lit(0), jen.Len(jen.Id("m").Dot("Discriminator").Call())),
					jen.If(jen.Op("!").Qual("bytes", "Equal").Call(jen.Id("discriminator"), jen.Id("m").Dot("Discriminator").Call())).Block(
						jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(jen.Lit("discriminator mismatch, expect %x, but got %x"), jen.Id("m").Dot("Discriminator").Call(), jen.Id("discriminator"))),
					),
					jen.Id("dec").Op(":=").Qual("github.com/gagliardetto/binary", "NewBorshDecoder").Call(
						jen.Id("data").Index(jen.Len(jen.Id("m").Dot("Discriminator").Call()).Op(":")),
					),
					jen.Err().Op(":=").Id("dec").Dot("Decode").Call(jen.Op("&").Id("m")),
					jen.Return(jen.Op("&").Id("m"), jen.Err()),
				).
				Line()
			f.Add(decodeFunc)
		}
	}
	sb := strings.Builder{}
	err := f.Render(&sb)
	if err != nil {
		return "", fmt.Errorf("render code failed: %v", err)
	}
	return sb.String(), nil
}

func generateInstructions(idl *IDL, file *jen.File, keepComment bool) error {
	for _, instruction := range idl.Instructions {
		fmt.Printf("generate struct for instruction %s\n", color.BlueString(instruction.Name))
		instructionName := snakeToCamel(instruction.Name)
		var instructionStruct *jen.Statement
		if keepComment && len(instruction.Docs) > 0 {
			instructionStruct = jen.Comment(strings.Join(instruction.Docs, "\n")).Line().Type()
		} else {
			instructionStruct = jen.Type()
		}
		instructionStruct.Id(instructionName)
		accountsID := fmt.Sprintf("%sAccounts", instructionName)
		argsID := ""

		acctFields := make([]jen.Code, len(instruction.Accounts))
		instructionStructFields := make([]jen.Code, 0)
		for i, acct := range instruction.Accounts {
			accountPublicName := snakeToCamel(acct.Name)
			acctFields[i] = jen.
				Id(accountPublicName).
				Qual("github.com/gagliardetto/solana-go", "PublicKey")
		}
		remainingAccounts := jen.Id("RemainingAccounts").
			Qual("github.com/gagliardetto/solana-go", "AccountMetaSlice")

		// struct InstructionAccounts
		file.Add(jen.Type().Id(accountsID).Struct(append(acctFields, remainingAccounts)...).Line())
		instructionStructFields = append(instructionStructFields, jen.Id("accounts").Qual("", accountsID))

		argsID = fmt.Sprintf("%sArgsStruct", instructionName)
		argFields := make([]jen.Code, len(instruction.Args))
		for i, arg := range instruction.Args {
			goType := arg.Type.GoType()
			if goType == nil {
				panic(fmt.Sprintf("arg %s is not supported", arg.Name))
			}
			goField := jen.Id(snakeToCamel(arg.Name)).Add(goType)
			argFields[i] = goField
		}
		// struct InstructionArgs
		file.Add(jen.Type().Id(argsID).Struct(argFields...).Line())
		instructionStructFields = append(instructionStructFields, jen.Id("args").Op("*").Qual("", argsID))

		instructionStructFields = append(instructionStructFields, jen.Id("programID").Op("*").Qual("github.com/gagliardetto/solana-go", "PublicKey"))
		// struct Instruction
		file.Add(instructionStruct.Struct(instructionStructFields...))

		// func: SetProgramID
		file.Add(
			jen.Func().
				Parens(jen.Id("m").Op("*").Id(instructionName)).
				Id("SetProgramID").Params(jen.Id("id").Qual("github.com/gagliardetto/solana-go", "PublicKey")).
				Op("*").Id(instructionName).
				Block(
					jen.Id("m").Dot("programID").Op("=").Op("&").Id("id"),
					jen.Return(jen.Id("m")),
				).
				Line(),
		)

		// func: ProgramID
		file.Add(
			jen.
				Func().
				Parens(jen.Id("m").Op("*").Id(instructionName)).
				Id("ProgramID").Params().Qual("github.com/gagliardetto/solana-go", "PublicKey").
				Block(
					jen.If(jen.Id("m").Dot("programID").Op("!=").Nil()).Block(
						jen.Return(jen.Op("*").Id("m").Dot("programID")),
					),
					jen.Return(jen.Id(snakeToCamel(idl.Metadata.Name)+"ProgramID")),
				).
				Line(),
		)

		// func: Discriminator
		file.Add(generateDiscriminator(instruction.Name, instruction.Discriminator).Line())

		var encodeArgsState jen.Statement
		if argsID != "" {
			encodeArgsState.Add(jen.Id("enc").Op(":=").Qual("github.com/gagliardetto/binary", "NewBorshEncoder").Call(jen.Op("&").Id("buf")),
				jen.Line(),
				jen.Err().Op(":=").Id("enc").Dot("Encode").Call(jen.Id("m").Dot("args")),
				jen.Line(),
				jen.If(jen.Err().Op("!=").Nil()).Block(
					jen.Return(jen.Nil(), jen.Err()),
				),
			)
		}

		// func: Build
		file.Add(
			jen.
				Func().
				Parens(jen.Id("m").Op("*").Id(instructionName)).
				Id("Build").
				Params().
				Parens(jen.List(jen.Qual("github.com/gagliardetto/solana-go", "Instruction"), jen.Error())).
				Block(
					jen.If(jen.Err().Op(":=").Id("m").Dot("calculateAccounts").Params(), jen.Err().Op("!=").Nil()).Block(jen.Return(jen.Nil(), jen.Err())),
					jen.Var().Id("generic").Qual("github.com/gagliardetto/solana-go", "GenericInstruction"),
					jen.Id("generic").Dot("ProgID").Op("=").Id("m").Dot("ProgramID").Call(),

					jen.Id("generic").Dot("AccountValues").Op("=").Qual("github.com/gagliardetto/solana-go", "AccountMetaSlice").ValuesFunc(func(group *jen.Group) {
						for _, acct := range instruction.Accounts {
							group.Values(jen.Dict{
								jen.Id("PublicKey"):  jen.Id("m").Dot("accounts").Dot(snakeToCamel(acct.Name)),
								jen.Id("IsWritable"): jen.Lit(acct.Writable),
								jen.Id("IsSigner"):   jen.Lit(acct.Signer),
							})
						}
					}),
					jen.For(jen.List(jen.Id("_"), jen.Id("item"))).Op(":=").Range().Id("m").Dot("accounts").Dot("RemainingAccounts").Block(
						jen.Id("generic").Dot("AccountValues").Op("=").Append(jen.Id("generic").Dot("AccountValues"), jen.Id("item")),
					),

					jen.Id("buf").Op(":=").Qual("bytes", "Buffer").Values(),
					jen.Id("buf").Dot("Write").Call(jen.Id("m").Dot("Discriminator").Call()),
					&encodeArgsState,
					jen.Id("generic").Dot("DataBytes").Op("=").Id("buf").Dot("Bytes").Call(),
					jen.Return(jen.List(jen.Op("&").Id("generic"), jen.Nil())),
				).
				Line(),
		)

		// func: Decode
		file.Add(
			jen.
				Func().
				Parens(jen.Id("m").Op("*").Id(instructionName)).
				Id("Decode").
				Params(
					jen.Id("accounts").Index().Qual("github.com/gagliardetto/solana-go", "PublicKey"),
					jen.Id("data").Index().Byte(),
				).
				Error().
				BlockFunc(func(group *jen.Group) {
					group.If(jen.Len(jen.Id("accounts")).Op("<").Lit(len(instruction.Accounts))).Block(
						jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("insufficient accounts, expect at least %d, but got %d"), jen.Lit(len(instruction.Accounts)), jen.Len(jen.Id("accounts")))),
					)
					for i, acct := range instruction.Accounts {
						group.Id("m").Dot("accounts").Dot(snakeToCamel(acct.Name)).Op("=").Id("accounts").Index(jen.Lit(i))
					}
					group.For(jen.List(jen.Id("_"), jen.Id("item"))).Op(":=").Range().Id("accounts").Index(jen.Lit(len(instruction.Accounts)).Op(":")).Block(
						jen.Id("m").Dot("accounts").Dot("RemainingAccounts").
							Op("=").
							Append(jen.Id("m").Dot("accounts").Dot("RemainingAccounts"), jen.Qual("github.com/gagliardetto/solana-go", "Meta").Call(jen.Id("item"))),
					)
					if argsID == "" {
						group.Return(jen.Nil())
					} else {
						group.Id("dec").Op(":=").Qual("github.com/gagliardetto/binary", "NewBorshDecoder").Call(
							jen.Id("data").Index(jen.Len(jen.Id("m").Dot("Discriminator").Call()).Op(":")),
						)
						group.Return(jen.Id("dec").Dot("Decode").Call(jen.Op("&").Id("m").Dot("args")))
					}
				}).
				Line(),
		)

		accountSetterCode := jen.Statement{}
		calculateAccountsCode := jen.Statement{}
		for _, acct := range instruction.Accounts {
			accountPublicName := snakeToCamel(acct.Name)
			// func: SetAccount
			accountSetterCode.Add(jen.Func().Parens(jen.Id("m").Op("*").Id(instructionName)).
				Id("SetAccount"+accountPublicName).Params(jen.Id("account").Qual("github.com/gagliardetto/solana-go", "PublicKey")).
				Op("*").Id(instructionName).
				Block(
					jen.Id("m").Dot("accounts").Dot(accountPublicName).Op("=").Id("account"),
					jen.Return(jen.Id("m")),
				).
				Line(),
			)
		}

		sortedAccounts := sortAccounts(instruction.Accounts)
		for _, acct := range sortedAccounts {
			accountPublicName := snakeToCamel(acct.Name)
			if acct.Address != "" {
				calculateAccountsCode.Add(
					jen.If(jen.Id("m").Dot("accounts").Dot(accountPublicName).Dot("IsZero").Call()).Block(
						jen.List(jen.Id("m").Dot("accounts").Dot(accountPublicName)).Op("=").Qual(
							"github.com/gagliardetto/solana-go",
							"MustPublicKeyFromBase58",
						).Call(
							jen.Lit(acct.Address)),
						jen.Line())).Line()
			} else if acct.Pda == nil {

			} else {
				seeds := jen.Statement{}
				for _, seed := range acct.Pda.Seeds {
					switch seed.Kind {
					case "const":
						seeds.Add(jen.ValuesFunc(func(group *jen.Group) {
							for _, v := range seed.Value {
								group.Add(jen.LitByte(v))
							}
						}))
					case "account":
						seeds.Add(jen.Id("m").Dot("accounts").Dot(snakeToCamel(seed.Path)).Dot("Bytes").Call())
					}
				}
				_group := &jen.Group{}
				seedsGroup := _group.Custom(jen.Options{
					Open:      "{",
					Close:     "}",
					Separator: ",",
					Multi:     true,
				}, seeds...)

				programIDSatement := jen.Id("m").Dot("ProgramID").Call()
				if acct.Pda.Program != nil {
					if acct.Pda.Program.Kind != "const" {
						panic(fmt.Sprintf("unknown program ID kind: %s", acct.Pda.Program.Kind))
					}
					programIDString := base58.Encode(acct.Pda.Program.Value)
					programIDSatement = jen.Qual("github.com/gagliardetto/solana-go", "MustPublicKeyFromBase58").Call(jen.Lit(programIDString))
				}
				calculateAccountsCode.Add(
					jen.If(jen.Id("m").Dot("accounts").Dot(accountPublicName).Dot("IsZero").Call()).Block(
						jen.List(jen.Id("m").Dot("accounts").Dot(accountPublicName), jen.Id("_"), jen.Id("err")).Op("=").Qual(
							"github.com/gagliardetto/solana-go",
							"FindProgramAddress",
						).Call(
							jen.Index().Index().Byte().Add(seedsGroup), programIDSatement),
						jen.Line(),
						jen.If(jen.Id("err").Op("!=").Nil()).Block(
							jen.Return(jen.Id("err")),
						),
						jen.Line()).Line(),
				)
			}
		}

		// func: accountSetter
		file.Add(&accountSetterCode)
		// func: calculateAccounts
		file.Add(jen.Func().Params(
			jen.Id("m").Op("*").Id(instructionName),
		).Id("calculateAccounts").Params().Params(
			jen.Id("err").Id("error"),
		).Block(
			&calculateAccountsCode,
			jen.Return(jen.Id("err")),
		))

		file.Add(generateAccounts(instructionName))
		file.Add(generateArgsSetter(instructionName))
		file.Add(generateArgs(instructionName))
	}
	return generateInstructionDecoder(idl, file)
}

func generateInstructionDecoder(idl *IDL, f *jen.File) error {
	// func: DecodeInstructionRaw
	f.Add(
		jen.Func().Id("Decode"+snakeToCamel(idl.Metadata.Name)+"InstructionRaw").
			Params(
				jen.Id("accounts").Index().Op("*").Qual("github.com/gagliardetto/solana-go", "AccountMeta"),
				jen.Id("data").Index().Byte(),
			).
			Params(
				jen.Id("decoded").Any(),
				jen.Id("ok").Bool(),
				jen.Err().Error(),
			).
			BlockFunc(
				func(group *jen.Group) {
					group.Id("mappings").Op(":=").Make(jen.Index().Qual("github.com/gagliardetto/solana-go", "PublicKey"), jen.Len(jen.Id("accounts")))
					group.For(jen.List(jen.Id("i"), jen.Id("item"))).Op(":=").Range().Id("accounts").Block(
						jen.Id("mappings").Index(jen.Id("i")).Op("=").Id("item").Dot("PublicKey"),
					)
					group.Return(jen.Id("Decode"+snakeToCamel(idl.Metadata.Name)+"Instruction").Call(jen.Id("mappings"), jen.Id("data")))
				},
			),
	)
	// func: DecodeInstruction
	f.Add(
		jen.Func().
			Id("Decode"+snakeToCamel(idl.Metadata.Name)+"Instruction").
			Params(
				jen.Id("accounts").Index().Qual("github.com/gagliardetto/solana-go", "PublicKey"),
				jen.Id("data").Index().Byte(),
			).
			Params(
				jen.Id("decoded").Any(),
				jen.Id("ok").Bool(),
				jen.Err().Error(),
			).
			BlockFunc(
				func(group *jen.Group) {
					group.If(jen.Len(jen.Id("data")).Op("<").Lit(8)).Block(
						jen.Return(jen.Nil(), jen.False(), jen.Qual("fmt", "Errorf").Call(jen.Lit("data length is less than 8 bytes"))),
					)
					group.Id("discriminator").Op(":=").Index(jen.Lit(8)).Byte().Parens(jen.Id("data").Index(jen.Lit(0), jen.Lit(8)))
					group.SwitchFunc(func(group *jen.Group) {
						group.Id("discriminator").
							BlockFunc(func(group *jen.Group) {
								for _, instruction := range idl.Instructions {
									if len(instruction.Discriminator) == 0 {
										continue // skip instruction without discriminator
									}
									group.CaseFunc(func(group *jen.Group) {
										group.Index(jen.Lit(len(instruction.Discriminator))).Byte().ValuesFunc(func(group *jen.Group) {
											for _, item := range instruction.Discriminator {
												group.Lit(item)
											}
										})
									})
									group.Var().Id("m").Op("=").Id(snakeToCamel(instruction.Name)).Values(jen.Dict{})
									group.Err().Op("=").Id("m").Dot("Decode").Call(jen.Id("accounts"), jen.Id("data"))
									group.Return(jen.Op("&").Id("m"), jen.True(), jen.Err())
								}
								group.Default().
									Return(jen.Nil(), jen.False(), jen.Nil())
							})
					})
				},
			),
	)
	return nil
}

func generateDiscriminator(name string, discriminator []byte) *jen.Statement {
	return jen.Func().
		Parens(jen.Id("m").Op("*").Id(snakeToCamel(name))).
		Id("Discriminator").Params().Index().Byte().Block(
		jen.Return(jen.Index().Byte().ValuesFunc(func(group *jen.Group) {
			for _, b := range discriminator {
				group.LitByte(b)
			}
		})),
	)
}

func generateAccounts(instructionName string) jen.Code {
	return jen.Func().
		Parens(jen.Id("m").Op("*").Id(instructionName)).
		Id("Accounts").Params().Op("*").Id(fmt.Sprintf("%sAccounts", instructionName)).Block(
		jen.Return(jen.Op("&").Id("m").Dot("accounts")),
	)
}

func generateArgs(instructionName string) jen.Code {
	return jen.Func().
		Parens(jen.Id("m").Op("*").Id(instructionName)).
		Id("Args").Params().Op("*").Id(fmt.Sprintf("%sArgsStruct", instructionName)).Block(
		jen.Return(jen.Id("m").Dot("args")),
	)
}

func generateArgsSetter(instructionName string) jen.Code {
	return jen.Func().
		Parens(jen.Id("m").Op("*").Id(instructionName)).
		Id("SetArgs").Params(jen.Id("args").Op("*").Id(fmt.Sprintf("%sArgsStruct", instructionName))).
		Op("*").Id(instructionName).Block(
		jen.Id("m").Dot("args").Op("=").Id("args"),
		jen.Return(jen.Id("m")),
	)
}

func writeToFile(filename, outputDir, src string) error {
	parts := strings.Split(filename, "/")
	dstFilename := parts[len(parts)-1]
	if strings.HasSuffix(dstFilename, ".json") {
		dstFilename = dstFilename[:len(dstFilename)-5]
	}
	dstFilename += ".go"
	if outputDir == "" {
		outputDir = filepath.Dir(filename)
	}
	dstPath := filepath.Join(outputDir, dstFilename)
	return os.WriteFile(dstPath, []byte(src), 0644)
}

// e.g. "snake_to_camel" -> "SnakeToCamel"
func snakeToCamel(snake string) string {
	parts := strings.Split(snake, "_")
	for i := range parts {
		parts[i] = cases.Title(language.English, cases.NoLower).String(parts[i])
	}
	return strings.Join(parts, "")
}

// e.g. "snake_to_private_camel" -> "snakeToPrivateCamel"
func snakeToPrivateCamel(snake string) string {
	parts := strings.Split(snake, "_")
	for i := range parts {
		if i == 0 {
			continue
		}
		parts[i] = cases.Title(language.English, cases.NoLower).String(parts[i])
	}
	return strings.Join(parts, "")
}

func sortAccounts(accounts []Account) []Account {
	dependencies := make(map[string][]string)
	for _, account := range accounts {
		dependencies[account.Name] = make([]string, 0)
		if account.Pda != nil {
			for _, seed := range account.Pda.Seeds {
				// no dependencies for const or arg seeds
				if seed.Kind == "const" || seed.Kind == "arg" {
					continue
				}
				if seed.Kind != "account" {
					panic("unknown kind for pda generation: " + seed.Kind)
				}
				dependencies[account.Name] = append(dependencies[account.Name], seed.Path) // A需要哪些依赖 eg, BC
			}
		}
	}

	inDegree := make(map[string]int)
	queue := list.New()
	for name, value := range dependencies {
		inDegree[name] = len(value)
		if len(value) == 0 {
			queue.PushBack(name)
		}
	}
	sortedNames := make([]string, 0)
	for queue.Len() > 0 {
		front := queue.Front()
		name := front.Value.(string)
		queue.Remove(front)
		sortedNames = append(sortedNames, name)
		for name2, dependency := range dependencies {
			for _, dependencyName := range dependency {
				if dependencyName == name {
					inDegree[name2]--
					if inDegree[name2] == 0 {
						queue.PushBack(name2)
					}
				}
			}

		}
	}
	newAccounts := make([]Account, 0)
	for _, name := range sortedNames {
		for _, account := range accounts {
			if account.Name == name {
				newAccounts = append(newAccounts, account)
			}
		}
	}
	return newAccounts
}
