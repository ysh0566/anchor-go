package main

import (
	"encoding/json"
	"fmt"
	"github.com/dave/jennifer/jen"
	"github.com/fatih/color"
	"github.com/spf13/cobra"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	rootCmd := cobra.Command{
		Use:  "solana-idl-generator [path to idl]",
		Args: cobra.ExactArgs(1),
	}
	packageName := rootCmd.Flags().String("package", "generated", "package name for generated code")
	keepComment := rootCmd.Flags().Bool("comment", true, "keep comments in generated code")
	decodeStruct := rootCmd.Flags().Bool("decode", true, "generate decode method for struct")
	instructions := rootCmd.Flags().Bool("instructions", true, "generate instructions")
	outputDir := rootCmd.Flags().String("output", "", "output directory for generated code")
	rootCmd.RunE = func(cmd *cobra.Command, args []string) error {
		filename := args[0]
		data, err := os.ReadFile(filename)
		if err != nil {
			return fmt.Errorf("read file failed: %v", err)
		}
		var idl IDL
		if err := json.Unmarshal(data, &idl); err != nil {
			return fmt.Errorf("unmarshal idl failed: %v", err)
		}

		src, err := generate(&idl, *packageName, *keepComment, *decodeStruct, *instructions)
		if err != nil {
			return err
		}

		return writeToFile(filename, *outputDir, src)
	}
	if err := rootCmd.Execute(); err != nil {
		_, _ = fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func generate(idl *IDL,
	packageName string, keepComment bool,
	decodeStruct bool, instructions bool,
) (string, error) {
	idl.Normalize() // normalize idl

	f := jen.NewFile(packageName)
	f.PackageComment("Code generated by solana-idl-generator. DO NOT EDIT.")
	f.ImportName("github.com/gagliardetto/solana-go", "solana")
	f.ImportName("github.com/gagliardetto/solana-go/rpc", "rpc")
	f.ImportAlias("github.com/gagliardetto/binary", "bin")
	f.ImportName("math/big", "big")

	programIdName := snakeToCamel(idl.Metadata.Name) + "ProgramID"
	f.Var().Id(programIdName).
		Op("=").
		Qual("github.com/gagliardetto/solana-go", "MustPublicKeyFromBase58").Call(jen.Lit(idl.Address.String()))

	if instructions {
		if err := generateInstructions(idl, f, keepComment); err != nil {
			return "", err
		}
	}

	acctTypes := idl.Types[:]
	for _, acct := range idl.Accounts {
		if acct.Type.Kind != "" {
			acctTypes = append(acctTypes, struct {
				Name string `json:"name"`
				Type Type   `json:"type"`
			}{Name: acct.Name, Type: acct.Type})
		}
	}
	for _, t := range acctTypes {
		if t.Name == "" {
			continue
		}
		if t.Type.Kind != "struct" {
			color.Cyan("type %s is not a struct, skipping", t.Name)
			continue
		}

		// generate struct
		fmt.Printf("generate struct for account %s\n", color.BlueString(t.Name))
		goFields := make([]jen.Code, 0)
		includeUnsupportedFields := false
		for _, field := range t.Type.Fields {
			goType := field.Type.GoType()
			if goType == nil {
				color.Cyan("field %s is not supported, skipping", field.Name)
				includeUnsupportedFields = true
				break
			}

			var goField *jen.Statement
			if len(field.Docs) > 0 && keepComment {
				goField = jen.Comment(strings.Join(field.Docs, "\n")).Line().Id(snakeToCamel(field.Name))
			} else {
				goField = jen.Id(snakeToCamel(field.Name))
			}
			goField.Add(goType)

			goFields = append(goFields, goField)
		}
		if includeUnsupportedFields {
			continue
		}
		s := jen.Type().Id(t.Name).Struct(goFields...)
		f.Add(s)

		hasDiscriminator := false
		// generate discriminator method
		for _, acct := range idl.Accounts {
			if acct.Name != t.Name {
				continue
			}
			hasDiscriminator = true
			// func: Discriminator
			f.Add(generateDiscriminator(t.Name, acct.Discriminator).Line())
			break
		}
		if !hasDiscriminator {
			f.Add(generateDiscriminator(t.Name, nil).Line()) // add empty discriminator
		}

		// generate decode method
		if decodeStruct {
			decodeFunc := jen.
				Func().
				Id("Decode"+t.Name).
				Params(
					jen.Id("resp").Op("*").Qual("github.com/gagliardetto/solana-go/rpc", "GetAccountInfoResult"),
				).
				Params(jen.Op("*").Id(t.Name), jen.Error()).
				Block(
					jen.Var().Id("m").Id(t.Name),
					jen.Id("data").Op(":=").Id("resp").Dot("GetBinary").Call(),
					jen.If(jen.Len(jen.Id("data")).Op("<").Len(jen.Id("m").Dot("Discriminator").Call())).Block(
						jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(jen.Lit("invalid response data"))),
					),
					jen.Id("discriminator").Op(":=").Id("data").Index(jen.Lit(0), jen.Len(jen.Id("m").Dot("Discriminator").Call())),
					jen.If(jen.Op("!").Qual("bytes", "Equal").Call(jen.Id("discriminator"), jen.Id("m").Dot("Discriminator").Call())).Block(
						jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(jen.Lit("discriminator mismatch, expect %x, but got %x"), jen.Id("m").Dot("Discriminator").Call(), jen.Id("discriminator"))),
					),
					jen.Id("dec").Op(":=").Qual("github.com/gagliardetto/binary", "NewBorshDecoder").Call(
						jen.Id("data").Index(jen.Len(jen.Id("m").Dot("Discriminator").Call()).Op(":")),
					),
					jen.Err().Op(":=").Id("dec").Dot("Decode").Call(jen.Op("&").Id("m")),
					jen.Return(jen.Op("&").Id("m"), jen.Err()),
				).
				Line()
			f.Add(decodeFunc)
		}
	}
	sb := strings.Builder{}
	err := f.Render(&sb)
	if err != nil {
		return "", fmt.Errorf("render code failed: %v", err)
	}
	return sb.String(), nil
}

func generateInstructions(idl *IDL, f *jen.File, keepComment bool) error {
	for _, instruction := range idl.Instructions {
		fmt.Printf("generate struct for instruction %s\n", color.BlueString(instruction.Name))
		var stat *jen.Statement
		if keepComment && len(instruction.Docs) > 0 {
			stat = jen.Comment(strings.Join(instruction.Docs, "\n")).Line().Type()
		} else {
			stat = jen.Type()
		}
		stat.Id(snakeToCamel(instruction.Name))

		acctFields := make([]jen.Code, len(instruction.Accounts))
		for i, acct := range instruction.Accounts {
			acctFields[i] = jen.
				Id(snakeToCamel(acct.Name)).
				Qual("github.com/gagliardetto/solana-go", "PublicKey")
		}
		accounts := jen.Id("Accounts").Struct(acctFields...)

		remainingAccounts := jen.Id("RemainingAccounts").
			Qual("github.com/gagliardetto/solana-go", "AccountMetaSlice")

		argFields := make([]jen.Code, len(instruction.Args))
		includeUnsupportedFields := false
		for i, arg := range instruction.Args {
			goType := arg.Type.GoType()
			if goType == nil {
				color.Cyan("arg %s is not supported, skipping", arg.Name)
				includeUnsupportedFields = true
				break
			}
			goField := jen.Id(snakeToCamel(arg.Name)).Add(goType)
			argFields[i] = goField
		}
		if includeUnsupportedFields {
			continue
		}
		args := jen.Id("Args").Struct(argFields...)

		stat.Struct(accounts, remainingAccounts, args,
			jen.Line(),
			jen.Id("programID").Op("*").Qual("github.com/gagliardetto/solana-go", "PublicKey"),
		)
		f.Add(stat)

		// func: SetProgramID
		f.Add(
			jen.Func().
				Parens(jen.Id("m").Op("*").Id(snakeToCamel(instruction.Name))).
				Id("SetProgramID").Params(jen.Id("id").Qual("github.com/gagliardetto/solana-go", "PublicKey")).
				Block(
					jen.Id("m").Dot("programID").Op("=").Op("&").Id("id"),
				).
				Line(),
		)

		// func: ProgramID
		f.Add(
			jen.
				Func().
				Parens(jen.Id("m").Op("*").Id(snakeToCamel(instruction.Name))).
				Id("ProgramID").Params().Qual("github.com/gagliardetto/solana-go", "PublicKey").
				Block(
					jen.If(jen.Id("m").Dot("programID").Op("!=").Nil()).Block(
						jen.Return(jen.Op("*").Id("m").Dot("programID")),
					),
					jen.Return(jen.Id(snakeToCamel(idl.Metadata.Name)+"ProgramID")),
				).
				Line(),
		)

		// func: Discriminator
		f.Add(generateDiscriminator(instruction.Name, instruction.Discriminator).Line())

		// func: Build
		f.Add(
			jen.
				Func().
				Parens(jen.Id("m").Op("*").Id(snakeToCamel(instruction.Name))).
				Id("Build").
				Params().
				Parens(jen.List(jen.Qual("github.com/gagliardetto/solana-go", "Instruction"), jen.Error())).
				Block(
					jen.Var().Id("generic").Qual("github.com/gagliardetto/solana-go", "GenericInstruction"),
					jen.Id("generic").Dot("ProgID").Op("=").Id("m").Dot("ProgramID").Call(),

					jen.Id("generic").Dot("AccountValues").Op("=").Qual("github.com/gagliardetto/solana-go", "AccountMetaSlice").ValuesFunc(func(group *jen.Group) {
						for _, acct := range instruction.Accounts {
							group.Values(jen.Dict{
								jen.Id("PublicKey"):  jen.Id("m").Dot("Accounts").Dot(snakeToCamel(acct.Name)),
								jen.Id("IsWritable"): jen.Lit(acct.Writable),
								jen.Id("IsSigner"):   jen.Lit(acct.Signer),
							})
						}
					}),
					jen.For(jen.List(jen.Id("_"), jen.Id("item"))).Op(":=").Range().Id("m").Dot("RemainingAccounts").Block(
						jen.Id("generic").Dot("AccountValues").Op("=").Append(jen.Id("generic").Dot("AccountValues"), jen.Id("item")),
					),

					jen.Id("buf").Op(":=").Qual("bytes", "Buffer").Values(),
					jen.Id("buf").Dot("Write").Call(jen.Id("m").Dot("Discriminator").Call()),
					jen.Id("enc").Op(":=").Qual("github.com/gagliardetto/binary", "NewBorshEncoder").Call(jen.Op("&").Id("buf")),
					jen.Err().Op(":=").Id("enc").Dot("Encode").Call(jen.Op("&").Id("m").Dot("Args")),
					jen.If(jen.Err().Op("!=").Nil()).Block(
						jen.Return(jen.Nil(), jen.Err()),
					),
					jen.Id("generic").Dot("DataBytes").Op("=").Id("buf").Dot("Bytes").Call(),
					jen.Return(jen.List(jen.Op("&").Id("generic"), jen.Nil())),
				).
				Line(),
		)

		// func: Decode
		f.Add(
			jen.
				Func().
				Parens(jen.Id("m").Op("*").Id(snakeToCamel(instruction.Name))).
				Id("Decode").
				Params(
					jen.Id("accounts").Index().Qual("github.com/gagliardetto/solana-go", "PublicKey"),
					jen.Id("data").Index().Byte(),
				).
				Error().
				BlockFunc(func(group *jen.Group) {
					group.If(jen.Len(jen.Id("accounts")).Op("<").Lit(len(instruction.Accounts))).Block(
						jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("insufficient accounts, expect at least %d, but got %d"), jen.Lit(len(instruction.Accounts)), jen.Len(jen.Id("accounts")))),
					)
					for i, acct := range instruction.Accounts {
						group.Id("m").Dot("Accounts").Dot(snakeToCamel(acct.Name)).Op("=").Id("accounts").Index(jen.Lit(i))
					}
					group.For(jen.List(jen.Id("_"), jen.Id("item"))).Op(":=").Range().Id("accounts").Index(jen.Lit(len(instruction.Accounts)).Op(":")).Block(
						jen.Id("m").Dot("RemainingAccounts").
							Op("=").
							Append(jen.Id("m").Dot("RemainingAccounts"), jen.Qual("github.com/gagliardetto/solana-go", "Meta").Call(jen.Id("item"))),
					)
					group.Id("dec").Op(":=").Qual("github.com/gagliardetto/binary", "NewBorshDecoder").Call(
						jen.Id("data").Index(jen.Len(jen.Id("m").Dot("Discriminator").Call()).Op(":")),
					)
					group.Return(jen.Id("dec").Dot("Decode").Call(jen.Op("&").Id("m").Dot("Args")))
				}).
				Line(),
		)
	}
	return generateInstructionDecoder(idl, f)
}

func generateInstructionDecoder(idl *IDL, f *jen.File) error {
	// func: DecodeInstructionRaw
	f.Add(
		jen.Func().Id("Decode"+snakeToCamel(idl.Metadata.Name)+"InstructionRaw").
			Params(
				jen.Id("accounts").Index().Op("*").Qual("github.com/gagliardetto/solana-go", "AccountMeta"),
				jen.Id("data").Index().Byte(),
			).
			Params(
				jen.Id("decoded").Any(),
				jen.Id("ok").Bool(),
				jen.Err().Error(),
			).
			BlockFunc(
				func(group *jen.Group) {
					group.Id("mappings").Op(":=").Make(jen.Index().Qual("github.com/gagliardetto/solana-go", "PublicKey"), jen.Len(jen.Id("accounts")))
					group.For(jen.List(jen.Id("i"), jen.Id("item"))).Op(":=").Range().Id("accounts").Block(
						jen.Id("mappings").Index(jen.Id("i")).Op("=").Id("item").Dot("PublicKey"),
					)
					group.Return(jen.Id("Decode"+snakeToCamel(idl.Metadata.Name)+"Instruction").Call(jen.Id("mappings"), jen.Id("data")))
				},
			),
	)
	// func: DecodeInstruction
	f.Add(
		jen.Func().
			Id("Decode"+snakeToCamel(idl.Metadata.Name)+"Instruction").
			Params(
				jen.Id("accounts").Index().Qual("github.com/gagliardetto/solana-go", "PublicKey"),
				jen.Id("data").Index().Byte(),
			).
			Params(
				jen.Id("decoded").Any(),
				jen.Id("ok").Bool(),
				jen.Err().Error(),
			).
			BlockFunc(
				func(group *jen.Group) {
					group.If(jen.Len(jen.Id("data")).Op("<").Lit(8)).Block(
						jen.Return(jen.Nil(), jen.False(), jen.Qual("fmt", "Errorf").Call(jen.Lit("data length is less than 8 bytes"))),
					)
					group.Id("discriminator").Op(":=").Index(jen.Lit(8)).Byte().Parens(jen.Id("data").Index(jen.Lit(0), jen.Lit(8)))
					group.SwitchFunc(func(group *jen.Group) {
						group.Id("discriminator").
							BlockFunc(func(group *jen.Group) {
								for _, instruction := range idl.Instructions {
									if len(instruction.Discriminator) == 0 {
										continue // skip instruction without discriminator
									}
									group.CaseFunc(func(group *jen.Group) {
										group.Index(jen.Lit(len(instruction.Discriminator))).Byte().ValuesFunc(func(group *jen.Group) {
											for _, item := range instruction.Discriminator {
												group.Lit(item)
											}
										})
									})
									group.Var().Id("m").Op("=").Id(snakeToCamel(instruction.Name)).Values(jen.Dict{})
									group.Err().Op("=").Id("m").Dot("Decode").Call(jen.Id("accounts"), jen.Id("data"))
									group.Return(jen.Op("&").Id("m"), jen.True(), jen.Err())
								}
								group.Default().
									Return(jen.Nil(), jen.False(), jen.Nil())
							})
					})
				},
			),
	)
	return nil
}

func generateDiscriminator(name string, discriminator []byte) *jen.Statement {
	return jen.Func().
		Parens(jen.Id("m").Op("*").Id(snakeToCamel(name))).
		Id("Discriminator").Params().Index().Byte().Block(
		jen.Return(jen.Index().Byte().ValuesFunc(func(group *jen.Group) {
			for _, b := range discriminator {
				group.Lit(b)
			}
		})),
	)
}

func writeToFile(filename, outputDir, src string) error {
	parts := strings.Split(filename, "/")
	dstFilename := parts[len(parts)-1]
	if strings.HasSuffix(dstFilename, ".json") {
		dstFilename = dstFilename[:len(dstFilename)-5]
	}
	dstFilename += ".go"
	if outputDir == "" {
		outputDir = filepath.Dir(filename)
	}
	dstPath := filepath.Join(outputDir, dstFilename)
	return os.WriteFile(dstPath, []byte(src), 0644)
}

// e.g. "snake_to_camel" -> "SnakeToCamel"
func snakeToCamel(snake string) string {
	parts := strings.Split(snake, "_")
	for i := range parts {
		parts[i] = cases.Title(language.English, cases.NoLower).String(parts[i])
	}
	return strings.Join(parts, "")
}

// e.g. "snake_to_private_camel" -> "snakeToPrivateCamel"
func snakeToPrivateCamel(snake string) string {
	parts := strings.Split(snake, "_")
	for i := range parts {
		if i == 0 {
			continue
		}
		parts[i] = cases.Title(language.English, cases.NoLower).String(parts[i])
	}
	return strings.Join(parts, "")
}
