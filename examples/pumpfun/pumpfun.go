// Code generated by anchor-go. DO NOT EDIT.
package generated

import (
	"bytes"
	"fmt"
	bin "github.com/gagliardetto/binary"
	"github.com/gagliardetto/solana-go"
	"github.com/gagliardetto/solana-go/rpc"
)

var PumpProgramID = solana.MustPublicKeyFromBase58("6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P")

type InitializeAccounts struct {
	Global            solana.PublicKey
	User              solana.PublicKey
	SystemProgram     solana.PublicKey
	RemainingAccounts solana.AccountMetaSlice
}

// Creates the global state.
type Initialize struct {
	accounts  InitializeAccounts
	programID *solana.PublicKey
}

func (m *Initialize) SetProgramID(id solana.PublicKey) *Initialize {
	m.programID = &id
	return m
}

func (m *Initialize) ProgramID() solana.PublicKey {
	if m.programID != nil {
		return *m.programID
	}
	return PumpProgramID
}

func (m *Initialize) Discriminator() []byte {
	return []byte{}
}

func (m *Initialize) Build() (solana.Instruction, error) {
	if err := m.calculateAccounts(); err != nil {
		return nil, err
	}
	var generic solana.GenericInstruction
	generic.ProgID = m.ProgramID()
	generic.AccountValues = solana.AccountMetaSlice{{
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Global,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.User,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.SystemProgram,
	}}
	for _, item := range m.accounts.RemainingAccounts {
		generic.AccountValues = append(generic.AccountValues, item)
	}
	buf := bytes.Buffer{}
	buf.Write(m.Discriminator())
	generic.DataBytes = buf.Bytes()
	return &generic, nil
}

func (m *Initialize) Decode(accounts []solana.PublicKey, data []byte) error {
	if len(accounts) < 3 {
		return fmt.Errorf("insufficient accounts, expect at least %d, but got %d", 3, len(accounts))
	}
	m.accounts.Global = accounts[0]
	m.accounts.User = accounts[1]
	m.accounts.SystemProgram = accounts[2]
	for _, item := range accounts[3:] {
		m.accounts.RemainingAccounts = append(m.accounts.RemainingAccounts, solana.Meta(item))
	}
	return nil
}

func (m *Initialize) SetAccountGlobal(account solana.PublicKey) *Initialize {
	m.accounts.Global = account
	return m
}
func (m *Initialize) SetAccountUser(account solana.PublicKey) *Initialize {
	m.accounts.User = account
	return m
}
func (m *Initialize) SetAccountSystemProgram(account solana.PublicKey) *Initialize {
	m.accounts.SystemProgram = account
	return m
}

func (m *Initialize) calculateAccounts() (err error) {
	return err
}
func (m *Initialize) Accounts() *InitializeAccounts {
	return &m.accounts
}
func (m *Initialize) Args() *InitializeArgsStruct {
	return &m.args
}

type SetParamsAccounts struct {
	Global            solana.PublicKey
	User              solana.PublicKey
	SystemProgram     solana.PublicKey
	EventAuthority    solana.PublicKey
	Program           solana.PublicKey
	RemainingAccounts solana.AccountMetaSlice
}

type SetParamsArgsStruct struct {
	FeeRecipient                solana.PublicKey
	InitialVirtualTokenReserves uint64
	InitialVirtualSolReserves   uint64
	InitialRealTokenReserves    uint64
	TokenTotalSupply            uint64
	FeeBasisPoints              uint64
}

// Sets the global state parameters.
type SetParams struct {
	accounts  SetParamsAccounts
	args      SetParamsArgsStruct
	programID *solana.PublicKey
}

func (m *SetParams) SetProgramID(id solana.PublicKey) *SetParams {
	m.programID = &id
	return m
}

func (m *SetParams) ProgramID() solana.PublicKey {
	if m.programID != nil {
		return *m.programID
	}
	return PumpProgramID
}

func (m *SetParams) Discriminator() []byte {
	return []byte{}
}

func (m *SetParams) Build() (solana.Instruction, error) {
	if err := m.calculateAccounts(); err != nil {
		return nil, err
	}
	var generic solana.GenericInstruction
	generic.ProgID = m.ProgramID()
	generic.AccountValues = solana.AccountMetaSlice{{
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Global,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.User,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.SystemProgram,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.EventAuthority,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Program,
	}}
	for _, item := range m.accounts.RemainingAccounts {
		generic.AccountValues = append(generic.AccountValues, item)
	}
	buf := bytes.Buffer{}
	buf.Write(m.Discriminator())
	enc := bin.NewBorshEncoder(&buf)
	err := enc.Encode(&m.args)
	if err != nil {
		return nil, err
	}
	generic.DataBytes = buf.Bytes()
	return &generic, nil
}

func (m *SetParams) Decode(accounts []solana.PublicKey, data []byte) error {
	if len(accounts) < 5 {
		return fmt.Errorf("insufficient accounts, expect at least %d, but got %d", 5, len(accounts))
	}
	m.accounts.Global = accounts[0]
	m.accounts.User = accounts[1]
	m.accounts.SystemProgram = accounts[2]
	m.accounts.EventAuthority = accounts[3]
	m.accounts.Program = accounts[4]
	for _, item := range accounts[5:] {
		m.accounts.RemainingAccounts = append(m.accounts.RemainingAccounts, solana.Meta(item))
	}
	dec := bin.NewBorshDecoder(data[len(m.Discriminator()):])
	return dec.Decode(&m.args)
}

func (m *SetParams) SetAccountGlobal(account solana.PublicKey) *SetParams {
	m.accounts.Global = account
	return m
}
func (m *SetParams) SetAccountUser(account solana.PublicKey) *SetParams {
	m.accounts.User = account
	return m
}
func (m *SetParams) SetAccountSystemProgram(account solana.PublicKey) *SetParams {
	m.accounts.SystemProgram = account
	return m
}
func (m *SetParams) SetAccountEventAuthority(account solana.PublicKey) *SetParams {
	m.accounts.EventAuthority = account
	return m
}
func (m *SetParams) SetAccountProgram(account solana.PublicKey) *SetParams {
	m.accounts.Program = account
	return m
}

func (m *SetParams) calculateAccounts() (err error) {
	return err
}
func (m *SetParams) Accounts() *SetParamsAccounts {
	return &m.accounts
}
func (m *SetParams) Args() *SetParamsArgsStruct {
	return &m.args
}

type CreateAccounts struct {
	Mint                   solana.PublicKey
	MintAuthority          solana.PublicKey
	BondingCurve           solana.PublicKey
	AssociatedBondingCurve solana.PublicKey
	Global                 solana.PublicKey
	MplTokenMetadata       solana.PublicKey
	Metadata               solana.PublicKey
	User                   solana.PublicKey
	SystemProgram          solana.PublicKey
	TokenProgram           solana.PublicKey
	AssociatedTokenProgram solana.PublicKey
	Rent                   solana.PublicKey
	EventAuthority         solana.PublicKey
	Program                solana.PublicKey
	RemainingAccounts      solana.AccountMetaSlice
}

type CreateArgsStruct struct {
	Name   string
	Symbol string
	Uri    string
}

// Creates a new coin and bonding curve.
type Create struct {
	accounts  CreateAccounts
	args      CreateArgsStruct
	programID *solana.PublicKey
}

func (m *Create) SetProgramID(id solana.PublicKey) *Create {
	m.programID = &id
	return m
}

func (m *Create) ProgramID() solana.PublicKey {
	if m.programID != nil {
		return *m.programID
	}
	return PumpProgramID
}

func (m *Create) Discriminator() []byte {
	return []byte{}
}

func (m *Create) Build() (solana.Instruction, error) {
	if err := m.calculateAccounts(); err != nil {
		return nil, err
	}
	var generic solana.GenericInstruction
	generic.ProgID = m.ProgramID()
	generic.AccountValues = solana.AccountMetaSlice{{
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Mint,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.MintAuthority,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.BondingCurve,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.AssociatedBondingCurve,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Global,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.MplTokenMetadata,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Metadata,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.User,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.SystemProgram,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.TokenProgram,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.AssociatedTokenProgram,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Rent,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.EventAuthority,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Program,
	}}
	for _, item := range m.accounts.RemainingAccounts {
		generic.AccountValues = append(generic.AccountValues, item)
	}
	buf := bytes.Buffer{}
	buf.Write(m.Discriminator())
	enc := bin.NewBorshEncoder(&buf)
	err := enc.Encode(&m.args)
	if err != nil {
		return nil, err
	}
	generic.DataBytes = buf.Bytes()
	return &generic, nil
}

func (m *Create) Decode(accounts []solana.PublicKey, data []byte) error {
	if len(accounts) < 14 {
		return fmt.Errorf("insufficient accounts, expect at least %d, but got %d", 14, len(accounts))
	}
	m.accounts.Mint = accounts[0]
	m.accounts.MintAuthority = accounts[1]
	m.accounts.BondingCurve = accounts[2]
	m.accounts.AssociatedBondingCurve = accounts[3]
	m.accounts.Global = accounts[4]
	m.accounts.MplTokenMetadata = accounts[5]
	m.accounts.Metadata = accounts[6]
	m.accounts.User = accounts[7]
	m.accounts.SystemProgram = accounts[8]
	m.accounts.TokenProgram = accounts[9]
	m.accounts.AssociatedTokenProgram = accounts[10]
	m.accounts.Rent = accounts[11]
	m.accounts.EventAuthority = accounts[12]
	m.accounts.Program = accounts[13]
	for _, item := range accounts[14:] {
		m.accounts.RemainingAccounts = append(m.accounts.RemainingAccounts, solana.Meta(item))
	}
	dec := bin.NewBorshDecoder(data[len(m.Discriminator()):])
	return dec.Decode(&m.args)
}

func (m *Create) SetAccountMint(account solana.PublicKey) *Create {
	m.accounts.Mint = account
	return m
}
func (m *Create) SetAccountMintAuthority(account solana.PublicKey) *Create {
	m.accounts.MintAuthority = account
	return m
}
func (m *Create) SetAccountBondingCurve(account solana.PublicKey) *Create {
	m.accounts.BondingCurve = account
	return m
}
func (m *Create) SetAccountAssociatedBondingCurve(account solana.PublicKey) *Create {
	m.accounts.AssociatedBondingCurve = account
	return m
}
func (m *Create) SetAccountGlobal(account solana.PublicKey) *Create {
	m.accounts.Global = account
	return m
}
func (m *Create) SetAccountMplTokenMetadata(account solana.PublicKey) *Create {
	m.accounts.MplTokenMetadata = account
	return m
}
func (m *Create) SetAccountMetadata(account solana.PublicKey) *Create {
	m.accounts.Metadata = account
	return m
}
func (m *Create) SetAccountUser(account solana.PublicKey) *Create {
	m.accounts.User = account
	return m
}
func (m *Create) SetAccountSystemProgram(account solana.PublicKey) *Create {
	m.accounts.SystemProgram = account
	return m
}
func (m *Create) SetAccountTokenProgram(account solana.PublicKey) *Create {
	m.accounts.TokenProgram = account
	return m
}
func (m *Create) SetAccountAssociatedTokenProgram(account solana.PublicKey) *Create {
	m.accounts.AssociatedTokenProgram = account
	return m
}
func (m *Create) SetAccountRent(account solana.PublicKey) *Create {
	m.accounts.Rent = account
	return m
}
func (m *Create) SetAccountEventAuthority(account solana.PublicKey) *Create {
	m.accounts.EventAuthority = account
	return m
}
func (m *Create) SetAccountProgram(account solana.PublicKey) *Create {
	m.accounts.Program = account
	return m
}

func (m *Create) calculateAccounts() (err error) {
	return err
}
func (m *Create) Accounts() *CreateAccounts {
	return &m.accounts
}
func (m *Create) Args() *CreateArgsStruct {
	return &m.args
}

type BuyAccounts struct {
	Global                 solana.PublicKey
	FeeRecipient           solana.PublicKey
	Mint                   solana.PublicKey
	BondingCurve           solana.PublicKey
	AssociatedBondingCurve solana.PublicKey
	AssociatedUser         solana.PublicKey
	User                   solana.PublicKey
	SystemProgram          solana.PublicKey
	TokenProgram           solana.PublicKey
	Rent                   solana.PublicKey
	EventAuthority         solana.PublicKey
	Program                solana.PublicKey
	RemainingAccounts      solana.AccountMetaSlice
}

type BuyArgsStruct struct {
	Amount     uint64
	MaxSolCost uint64
}

// Buys tokens from a bonding curve.
type Buy struct {
	accounts  BuyAccounts
	args      BuyArgsStruct
	programID *solana.PublicKey
}

func (m *Buy) SetProgramID(id solana.PublicKey) *Buy {
	m.programID = &id
	return m
}

func (m *Buy) ProgramID() solana.PublicKey {
	if m.programID != nil {
		return *m.programID
	}
	return PumpProgramID
}

func (m *Buy) Discriminator() []byte {
	return []byte{}
}

func (m *Buy) Build() (solana.Instruction, error) {
	if err := m.calculateAccounts(); err != nil {
		return nil, err
	}
	var generic solana.GenericInstruction
	generic.ProgID = m.ProgramID()
	generic.AccountValues = solana.AccountMetaSlice{{
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Global,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.FeeRecipient,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Mint,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.BondingCurve,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.AssociatedBondingCurve,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.AssociatedUser,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.User,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.SystemProgram,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.TokenProgram,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Rent,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.EventAuthority,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Program,
	}}
	for _, item := range m.accounts.RemainingAccounts {
		generic.AccountValues = append(generic.AccountValues, item)
	}
	buf := bytes.Buffer{}
	buf.Write(m.Discriminator())
	enc := bin.NewBorshEncoder(&buf)
	err := enc.Encode(&m.args)
	if err != nil {
		return nil, err
	}
	generic.DataBytes = buf.Bytes()
	return &generic, nil
}

func (m *Buy) Decode(accounts []solana.PublicKey, data []byte) error {
	if len(accounts) < 12 {
		return fmt.Errorf("insufficient accounts, expect at least %d, but got %d", 12, len(accounts))
	}
	m.accounts.Global = accounts[0]
	m.accounts.FeeRecipient = accounts[1]
	m.accounts.Mint = accounts[2]
	m.accounts.BondingCurve = accounts[3]
	m.accounts.AssociatedBondingCurve = accounts[4]
	m.accounts.AssociatedUser = accounts[5]
	m.accounts.User = accounts[6]
	m.accounts.SystemProgram = accounts[7]
	m.accounts.TokenProgram = accounts[8]
	m.accounts.Rent = accounts[9]
	m.accounts.EventAuthority = accounts[10]
	m.accounts.Program = accounts[11]
	for _, item := range accounts[12:] {
		m.accounts.RemainingAccounts = append(m.accounts.RemainingAccounts, solana.Meta(item))
	}
	dec := bin.NewBorshDecoder(data[len(m.Discriminator()):])
	return dec.Decode(&m.args)
}

func (m *Buy) SetAccountGlobal(account solana.PublicKey) *Buy {
	m.accounts.Global = account
	return m
}
func (m *Buy) SetAccountFeeRecipient(account solana.PublicKey) *Buy {
	m.accounts.FeeRecipient = account
	return m
}
func (m *Buy) SetAccountMint(account solana.PublicKey) *Buy {
	m.accounts.Mint = account
	return m
}
func (m *Buy) SetAccountBondingCurve(account solana.PublicKey) *Buy {
	m.accounts.BondingCurve = account
	return m
}
func (m *Buy) SetAccountAssociatedBondingCurve(account solana.PublicKey) *Buy {
	m.accounts.AssociatedBondingCurve = account
	return m
}
func (m *Buy) SetAccountAssociatedUser(account solana.PublicKey) *Buy {
	m.accounts.AssociatedUser = account
	return m
}
func (m *Buy) SetAccountUser(account solana.PublicKey) *Buy {
	m.accounts.User = account
	return m
}
func (m *Buy) SetAccountSystemProgram(account solana.PublicKey) *Buy {
	m.accounts.SystemProgram = account
	return m
}
func (m *Buy) SetAccountTokenProgram(account solana.PublicKey) *Buy {
	m.accounts.TokenProgram = account
	return m
}
func (m *Buy) SetAccountRent(account solana.PublicKey) *Buy {
	m.accounts.Rent = account
	return m
}
func (m *Buy) SetAccountEventAuthority(account solana.PublicKey) *Buy {
	m.accounts.EventAuthority = account
	return m
}
func (m *Buy) SetAccountProgram(account solana.PublicKey) *Buy {
	m.accounts.Program = account
	return m
}

func (m *Buy) calculateAccounts() (err error) {
	return err
}
func (m *Buy) Accounts() *BuyAccounts {
	return &m.accounts
}
func (m *Buy) Args() *BuyArgsStruct {
	return &m.args
}

type SellAccounts struct {
	Global                 solana.PublicKey
	FeeRecipient           solana.PublicKey
	Mint                   solana.PublicKey
	BondingCurve           solana.PublicKey
	AssociatedBondingCurve solana.PublicKey
	AssociatedUser         solana.PublicKey
	User                   solana.PublicKey
	SystemProgram          solana.PublicKey
	AssociatedTokenProgram solana.PublicKey
	TokenProgram           solana.PublicKey
	EventAuthority         solana.PublicKey
	Program                solana.PublicKey
	RemainingAccounts      solana.AccountMetaSlice
}

type SellArgsStruct struct {
	Amount       uint64
	MinSolOutput uint64
}

// Sells tokens into a bonding curve.
type Sell struct {
	accounts  SellAccounts
	args      SellArgsStruct
	programID *solana.PublicKey
}

func (m *Sell) SetProgramID(id solana.PublicKey) *Sell {
	m.programID = &id
	return m
}

func (m *Sell) ProgramID() solana.PublicKey {
	if m.programID != nil {
		return *m.programID
	}
	return PumpProgramID
}

func (m *Sell) Discriminator() []byte {
	return []byte{}
}

func (m *Sell) Build() (solana.Instruction, error) {
	if err := m.calculateAccounts(); err != nil {
		return nil, err
	}
	var generic solana.GenericInstruction
	generic.ProgID = m.ProgramID()
	generic.AccountValues = solana.AccountMetaSlice{{
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Global,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.FeeRecipient,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Mint,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.BondingCurve,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.AssociatedBondingCurve,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.AssociatedUser,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.User,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.SystemProgram,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.AssociatedTokenProgram,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.TokenProgram,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.EventAuthority,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Program,
	}}
	for _, item := range m.accounts.RemainingAccounts {
		generic.AccountValues = append(generic.AccountValues, item)
	}
	buf := bytes.Buffer{}
	buf.Write(m.Discriminator())
	enc := bin.NewBorshEncoder(&buf)
	err := enc.Encode(&m.args)
	if err != nil {
		return nil, err
	}
	generic.DataBytes = buf.Bytes()
	return &generic, nil
}

func (m *Sell) Decode(accounts []solana.PublicKey, data []byte) error {
	if len(accounts) < 12 {
		return fmt.Errorf("insufficient accounts, expect at least %d, but got %d", 12, len(accounts))
	}
	m.accounts.Global = accounts[0]
	m.accounts.FeeRecipient = accounts[1]
	m.accounts.Mint = accounts[2]
	m.accounts.BondingCurve = accounts[3]
	m.accounts.AssociatedBondingCurve = accounts[4]
	m.accounts.AssociatedUser = accounts[5]
	m.accounts.User = accounts[6]
	m.accounts.SystemProgram = accounts[7]
	m.accounts.AssociatedTokenProgram = accounts[8]
	m.accounts.TokenProgram = accounts[9]
	m.accounts.EventAuthority = accounts[10]
	m.accounts.Program = accounts[11]
	for _, item := range accounts[12:] {
		m.accounts.RemainingAccounts = append(m.accounts.RemainingAccounts, solana.Meta(item))
	}
	dec := bin.NewBorshDecoder(data[len(m.Discriminator()):])
	return dec.Decode(&m.args)
}

func (m *Sell) SetAccountGlobal(account solana.PublicKey) *Sell {
	m.accounts.Global = account
	return m
}
func (m *Sell) SetAccountFeeRecipient(account solana.PublicKey) *Sell {
	m.accounts.FeeRecipient = account
	return m
}
func (m *Sell) SetAccountMint(account solana.PublicKey) *Sell {
	m.accounts.Mint = account
	return m
}
func (m *Sell) SetAccountBondingCurve(account solana.PublicKey) *Sell {
	m.accounts.BondingCurve = account
	return m
}
func (m *Sell) SetAccountAssociatedBondingCurve(account solana.PublicKey) *Sell {
	m.accounts.AssociatedBondingCurve = account
	return m
}
func (m *Sell) SetAccountAssociatedUser(account solana.PublicKey) *Sell {
	m.accounts.AssociatedUser = account
	return m
}
func (m *Sell) SetAccountUser(account solana.PublicKey) *Sell {
	m.accounts.User = account
	return m
}
func (m *Sell) SetAccountSystemProgram(account solana.PublicKey) *Sell {
	m.accounts.SystemProgram = account
	return m
}
func (m *Sell) SetAccountAssociatedTokenProgram(account solana.PublicKey) *Sell {
	m.accounts.AssociatedTokenProgram = account
	return m
}
func (m *Sell) SetAccountTokenProgram(account solana.PublicKey) *Sell {
	m.accounts.TokenProgram = account
	return m
}
func (m *Sell) SetAccountEventAuthority(account solana.PublicKey) *Sell {
	m.accounts.EventAuthority = account
	return m
}
func (m *Sell) SetAccountProgram(account solana.PublicKey) *Sell {
	m.accounts.Program = account
	return m
}

func (m *Sell) calculateAccounts() (err error) {
	return err
}
func (m *Sell) Accounts() *SellAccounts {
	return &m.accounts
}
func (m *Sell) Args() *SellArgsStruct {
	return &m.args
}

type WithdrawAccounts struct {
	Global                 solana.PublicKey
	Mint                   solana.PublicKey
	BondingCurve           solana.PublicKey
	AssociatedBondingCurve solana.PublicKey
	AssociatedUser         solana.PublicKey
	User                   solana.PublicKey
	SystemProgram          solana.PublicKey
	TokenProgram           solana.PublicKey
	Rent                   solana.PublicKey
	EventAuthority         solana.PublicKey
	Program                solana.PublicKey
	RemainingAccounts      solana.AccountMetaSlice
}

// Allows the admin to withdraw liquidity for a migration once the bonding curve completes
type Withdraw struct {
	accounts  WithdrawAccounts
	programID *solana.PublicKey
}

func (m *Withdraw) SetProgramID(id solana.PublicKey) *Withdraw {
	m.programID = &id
	return m
}

func (m *Withdraw) ProgramID() solana.PublicKey {
	if m.programID != nil {
		return *m.programID
	}
	return PumpProgramID
}

func (m *Withdraw) Discriminator() []byte {
	return []byte{}
}

func (m *Withdraw) Build() (solana.Instruction, error) {
	if err := m.calculateAccounts(); err != nil {
		return nil, err
	}
	var generic solana.GenericInstruction
	generic.ProgID = m.ProgramID()
	generic.AccountValues = solana.AccountMetaSlice{{
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Global,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Mint,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.BondingCurve,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.AssociatedBondingCurve,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.AssociatedUser,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.User,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.SystemProgram,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.TokenProgram,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Rent,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.EventAuthority,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.Program,
	}}
	for _, item := range m.accounts.RemainingAccounts {
		generic.AccountValues = append(generic.AccountValues, item)
	}
	buf := bytes.Buffer{}
	buf.Write(m.Discriminator())
	generic.DataBytes = buf.Bytes()
	return &generic, nil
}

func (m *Withdraw) Decode(accounts []solana.PublicKey, data []byte) error {
	if len(accounts) < 11 {
		return fmt.Errorf("insufficient accounts, expect at least %d, but got %d", 11, len(accounts))
	}
	m.accounts.Global = accounts[0]
	m.accounts.Mint = accounts[1]
	m.accounts.BondingCurve = accounts[2]
	m.accounts.AssociatedBondingCurve = accounts[3]
	m.accounts.AssociatedUser = accounts[4]
	m.accounts.User = accounts[5]
	m.accounts.SystemProgram = accounts[6]
	m.accounts.TokenProgram = accounts[7]
	m.accounts.Rent = accounts[8]
	m.accounts.EventAuthority = accounts[9]
	m.accounts.Program = accounts[10]
	for _, item := range accounts[11:] {
		m.accounts.RemainingAccounts = append(m.accounts.RemainingAccounts, solana.Meta(item))
	}
	return nil
}

func (m *Withdraw) SetAccountGlobal(account solana.PublicKey) *Withdraw {
	m.accounts.Global = account
	return m
}
func (m *Withdraw) SetAccountMint(account solana.PublicKey) *Withdraw {
	m.accounts.Mint = account
	return m
}
func (m *Withdraw) SetAccountBondingCurve(account solana.PublicKey) *Withdraw {
	m.accounts.BondingCurve = account
	return m
}
func (m *Withdraw) SetAccountAssociatedBondingCurve(account solana.PublicKey) *Withdraw {
	m.accounts.AssociatedBondingCurve = account
	return m
}
func (m *Withdraw) SetAccountAssociatedUser(account solana.PublicKey) *Withdraw {
	m.accounts.AssociatedUser = account
	return m
}
func (m *Withdraw) SetAccountUser(account solana.PublicKey) *Withdraw {
	m.accounts.User = account
	return m
}
func (m *Withdraw) SetAccountSystemProgram(account solana.PublicKey) *Withdraw {
	m.accounts.SystemProgram = account
	return m
}
func (m *Withdraw) SetAccountTokenProgram(account solana.PublicKey) *Withdraw {
	m.accounts.TokenProgram = account
	return m
}
func (m *Withdraw) SetAccountRent(account solana.PublicKey) *Withdraw {
	m.accounts.Rent = account
	return m
}
func (m *Withdraw) SetAccountEventAuthority(account solana.PublicKey) *Withdraw {
	m.accounts.EventAuthority = account
	return m
}
func (m *Withdraw) SetAccountProgram(account solana.PublicKey) *Withdraw {
	m.accounts.Program = account
	return m
}

func (m *Withdraw) calculateAccounts() (err error) {
	return err
}
func (m *Withdraw) Accounts() *WithdrawAccounts {
	return &m.accounts
}
func (m *Withdraw) Args() *WithdrawArgsStruct {
	return &m.args
}
func DecodePumpInstructionRaw(accounts []*solana.AccountMeta, data []byte) (decoded any, ok bool, err error) {
	mappings := make([]solana.PublicKey, len(accounts))
	for i, item := range accounts {
		mappings[i] = item.PublicKey
	}
	return DecodePumpInstruction(mappings, data)
}
func DecodePumpInstruction(accounts []solana.PublicKey, data []byte) (decoded any, ok bool, err error) {
	if len(data) < 8 {
		return nil, false, fmt.Errorf("data length is less than 8 bytes")
	}
	discriminator := [8]byte(data[0:8])
	switch discriminator {
	default:
		return nil, false, nil
	}
}

type Global struct {
	Initialized                 bool
	Authority                   solana.PublicKey
	FeeRecipient                solana.PublicKey
	InitialVirtualTokenReserves uint64
	InitialVirtualSolReserves   uint64
	InitialRealTokenReserves    uint64
	TokenTotalSupply            uint64
	FeeBasisPoints              uint64
}

func (m *Global) Discriminator() []byte {
	return []byte{}
}

func DecodeGlobal(resp *rpc.GetAccountInfoResult) (*Global, error) {
	var m Global
	data := resp.GetBinary()
	if len(data) < len(m.Discriminator()) {
		return nil, fmt.Errorf("invalid response data")
	}
	discriminator := data[0:len(m.Discriminator())]
	if !bytes.Equal(discriminator, m.Discriminator()) {
		return nil, fmt.Errorf("discriminator mismatch, expect %x, but got %x", m.Discriminator(), discriminator)
	}
	dec := bin.NewBorshDecoder(data[len(m.Discriminator()):])
	err := dec.Decode(&m)
	return &m, err
}

type BondingCurve struct {
	VirtualTokenReserves uint64
	VirtualSolReserves   uint64
	RealTokenReserves    uint64
	RealSolReserves      uint64
	TokenTotalSupply     uint64
	Complete             bool
}

func (m *BondingCurve) Discriminator() []byte {
	return []byte{}
}

func DecodeBondingCurve(resp *rpc.GetAccountInfoResult) (*BondingCurve, error) {
	var m BondingCurve
	data := resp.GetBinary()
	if len(data) < len(m.Discriminator()) {
		return nil, fmt.Errorf("invalid response data")
	}
	discriminator := data[0:len(m.Discriminator())]
	if !bytes.Equal(discriminator, m.Discriminator()) {
		return nil, fmt.Errorf("discriminator mismatch, expect %x, but got %x", m.Discriminator(), discriminator)
	}
	dec := bin.NewBorshDecoder(data[len(m.Discriminator()):])
	err := dec.Decode(&m)
	return &m, err
}
