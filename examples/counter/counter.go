// Code generated by anchor-go. DO NOT EDIT.
package generated

import (
	"bytes"
	"fmt"
	bin "github.com/gagliardetto/binary"
	"github.com/gagliardetto/solana-go"
	"github.com/gagliardetto/solana-go/rpc"
)

var AnchorCounterProgramID = solana.MustPublicKeyFromBase58("9sMy4hnC9MML6mioESFZmzpntt3focqwUq1ymPgbMf64")

type IncrementAccounts struct {
	Counter           solana.PublicKey
	User              solana.PublicKey
	RemainingAccounts solana.AccountMetaSlice
}

type Increment struct {
	accounts  IncrementAccounts
	programID *solana.PublicKey
}

func (m *Increment) SetProgramID(id solana.PublicKey) *Increment {
	m.programID = &id
	return m
}

func (m *Increment) ProgramID() solana.PublicKey {
	if m.programID != nil {
		return *m.programID
	}
	return AnchorCounterProgramID
}

func (m *Increment) Discriminator() []byte {
	return []byte{byte(0xb), byte(0x12), byte(0x68), byte(0x9), byte(0x68), byte(0xae), byte(0x3b), byte(0x21)}
}

func (m *Increment) Build() (solana.Instruction, error) {
	if err := m.calculateAccounts(); err != nil {
		return nil, err
	}
	var generic solana.GenericInstruction
	generic.ProgID = m.ProgramID()
	generic.AccountValues = solana.AccountMetaSlice{{
		IsSigner:   false,
		IsWritable: true,
		PublicKey:  m.accounts.Counter,
	}, {
		IsSigner:   true,
		IsWritable: false,
		PublicKey:  m.accounts.User,
	}}
	for _, item := range m.accounts.RemainingAccounts {
		generic.AccountValues = append(generic.AccountValues, item)
	}
	buf := bytes.Buffer{}
	buf.Write(m.Discriminator())
	generic.DataBytes = buf.Bytes()
	return &generic, nil
}

func (m *Increment) Decode(accounts []solana.PublicKey, data []byte) error {
	if len(accounts) < 2 {
		return fmt.Errorf("insufficient accounts, expect at least %d, but got %d", 2, len(accounts))
	}
	m.accounts.Counter = accounts[0]
	m.accounts.User = accounts[1]
	for _, item := range accounts[2:] {
		m.accounts.RemainingAccounts = append(m.accounts.RemainingAccounts, solana.Meta(item))
	}
	return nil
}

func (m *Increment) SetAccountCounter(account solana.PublicKey) *Increment {
	m.accounts.Counter = account
	return m
}
func (m *Increment) SetAccountUser(account solana.PublicKey) *Increment {
	m.accounts.User = account
	return m
}

func (m *Increment) calculateAccounts() (err error) {
	return err
}
func (m *Increment) Accounts() *IncrementAccounts {
	return &m.accounts
}
func (m *Increment) Args() *IncrementArgsStruct {
	return &m.args
}

type InitializeAccounts struct {
	Counter           solana.PublicKey
	User              solana.PublicKey
	SystemProgram     solana.PublicKey
	RemainingAccounts solana.AccountMetaSlice
}

type Initialize struct {
	accounts  InitializeAccounts
	programID *solana.PublicKey
}

func (m *Initialize) SetProgramID(id solana.PublicKey) *Initialize {
	m.programID = &id
	return m
}

func (m *Initialize) ProgramID() solana.PublicKey {
	if m.programID != nil {
		return *m.programID
	}
	return AnchorCounterProgramID
}

func (m *Initialize) Discriminator() []byte {
	return []byte{byte(0xaf), byte(0xaf), byte(0x6d), byte(0x1f), byte(0xd), byte(0x98), byte(0x9b), byte(0xed)}
}

func (m *Initialize) Build() (solana.Instruction, error) {
	if err := m.calculateAccounts(); err != nil {
		return nil, err
	}
	var generic solana.GenericInstruction
	generic.ProgID = m.ProgramID()
	generic.AccountValues = solana.AccountMetaSlice{{
		IsSigner:   true,
		IsWritable: true,
		PublicKey:  m.accounts.Counter,
	}, {
		IsSigner:   true,
		IsWritable: true,
		PublicKey:  m.accounts.User,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.accounts.SystemProgram,
	}}
	for _, item := range m.accounts.RemainingAccounts {
		generic.AccountValues = append(generic.AccountValues, item)
	}
	buf := bytes.Buffer{}
	buf.Write(m.Discriminator())
	generic.DataBytes = buf.Bytes()
	return &generic, nil
}

func (m *Initialize) Decode(accounts []solana.PublicKey, data []byte) error {
	if len(accounts) < 3 {
		return fmt.Errorf("insufficient accounts, expect at least %d, but got %d", 3, len(accounts))
	}
	m.accounts.Counter = accounts[0]
	m.accounts.User = accounts[1]
	m.accounts.SystemProgram = accounts[2]
	for _, item := range accounts[3:] {
		m.accounts.RemainingAccounts = append(m.accounts.RemainingAccounts, solana.Meta(item))
	}
	return nil
}

func (m *Initialize) SetAccountCounter(account solana.PublicKey) *Initialize {
	m.accounts.Counter = account
	return m
}
func (m *Initialize) SetAccountUser(account solana.PublicKey) *Initialize {
	m.accounts.User = account
	return m
}
func (m *Initialize) SetAccountSystemProgram(account solana.PublicKey) *Initialize {
	m.accounts.SystemProgram = account
	return m
}

func (m *Initialize) calculateAccounts() (err error) {
	return err
}
func (m *Initialize) Accounts() *InitializeAccounts {
	return &m.accounts
}
func (m *Initialize) Args() *InitializeArgsStruct {
	return &m.args
}
func DecodeAnchorCounterInstructionRaw(accounts []*solana.AccountMeta, data []byte) (decoded any, ok bool, err error) {
	mappings := make([]solana.PublicKey, len(accounts))
	for i, item := range accounts {
		mappings[i] = item.PublicKey
	}
	return DecodeAnchorCounterInstruction(mappings, data)
}
func DecodeAnchorCounterInstruction(accounts []solana.PublicKey, data []byte) (decoded any, ok bool, err error) {
	if len(data) < 8 {
		return nil, false, fmt.Errorf("data length is less than 8 bytes")
	}
	discriminator := [8]byte(data[0:8])
	switch discriminator {
	case [8]byte{uint8(0xb), uint8(0x12), uint8(0x68), uint8(0x9), uint8(0x68), uint8(0xae), uint8(0x3b), uint8(0x21)}:
		var m = Increment{}
		err = m.Decode(accounts, data)
		return &m, true, err
	case [8]byte{uint8(0xaf), uint8(0xaf), uint8(0x6d), uint8(0x1f), uint8(0xd), uint8(0x98), uint8(0x9b), uint8(0xed)}:
		var m = Initialize{}
		err = m.Decode(accounts, data)
		return &m, true, err
	default:
		return nil, false, nil
	}
}

type Counter struct {
	Count uint64
}

func (m *Counter) Discriminator() []byte {
	return []byte{byte(0xff), byte(0xb0), byte(0x4), byte(0xf5), byte(0xbc), byte(0xfd), byte(0x7c), byte(0x19)}
}

func DecodeCounter(resp *rpc.GetAccountInfoResult) (*Counter, error) {
	var m Counter
	data := resp.GetBinary()
	if len(data) < len(m.Discriminator()) {
		return nil, fmt.Errorf("invalid response data")
	}
	discriminator := data[0:len(m.Discriminator())]
	if !bytes.Equal(discriminator, m.Discriminator()) {
		return nil, fmt.Errorf("discriminator mismatch, expect %x, but got %x", m.Discriminator(), discriminator)
	}
	dec := bin.NewBorshDecoder(data[len(m.Discriminator()):])
	err := dec.Decode(&m)
	return &m, err
}
