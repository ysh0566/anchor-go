// Code generated by solana-idl-generator. DO NOT EDIT.
package counter

import (
	"bytes"
	"fmt"
	bin "github.com/gagliardetto/binary"
	"github.com/gagliardetto/solana-go"
	"github.com/gagliardetto/solana-go/rpc"
)

var AnchorCounterProgramID = solana.MustPublicKeyFromBase58("9sMy4hnC9MML6mioESFZmzpntt3focqwUq1ymPgbMf64")

type Increment struct {
	Accounts struct {
		Counter solana.PublicKey
		User    solana.PublicKey
	}
	RemainingAccounts solana.AccountMetaSlice
	Args              struct{}

	programID *solana.PublicKey
}

func (m *Increment) SetProgramID(id solana.PublicKey) {
	m.programID = &id
}

func (m *Increment) ProgramID() solana.PublicKey {
	if m.programID != nil {
		return *m.programID
	}
	return AnchorCounterProgramID
}

func (m *Increment) Discriminator() []byte {
	return []byte{uint8(0xb), uint8(0x12), uint8(0x68), uint8(0x9), uint8(0x68), uint8(0xae), uint8(0x3b), uint8(0x21)}
}

func (m *Increment) Build() (solana.Instruction, error) {
	var generic solana.GenericInstruction
	generic.ProgID = m.ProgramID()
	generic.AccountValues = solana.AccountMetaSlice{{
		IsSigner:   false,
		IsWritable: true,
		PublicKey:  m.Accounts.Counter,
	}, {
		IsSigner:   true,
		IsWritable: false,
		PublicKey:  m.Accounts.User,
	}}
	for _, item := range m.RemainingAccounts {
		generic.AccountValues = append(generic.AccountValues, item)
	}
	buf := bytes.Buffer{}
	buf.Write(m.Discriminator())
	enc := bin.NewBorshEncoder(&buf)
	err := enc.Encode(&m.Args)
	if err != nil {
		return nil, err
	}
	generic.DataBytes = buf.Bytes()
	return &generic, nil
}

func (m *Increment) Decode(accounts []solana.PublicKey, data []byte) error {
	if len(accounts) < 2 {
		return fmt.Errorf("insufficient accounts, expect at least %d, but got %d", 2, len(accounts))
	}
	m.Accounts.Counter = accounts[0]
	m.Accounts.User = accounts[1]
	for _, item := range accounts[2:] {
		m.RemainingAccounts = append(m.RemainingAccounts, solana.Meta(item))
	}
	dec := bin.NewBorshDecoder(data[len(m.Discriminator()):])
	return dec.Decode(&m.Args)
}

type Initialize struct {
	Accounts struct {
		Counter       solana.PublicKey
		User          solana.PublicKey
		SystemProgram solana.PublicKey
	}
	RemainingAccounts solana.AccountMetaSlice
	Args              struct{}

	programID *solana.PublicKey
}

func (m *Initialize) SetProgramID(id solana.PublicKey) {
	m.programID = &id
}

func (m *Initialize) ProgramID() solana.PublicKey {
	if m.programID != nil {
		return *m.programID
	}
	return AnchorCounterProgramID
}

func (m *Initialize) Discriminator() []byte {
	return []byte{uint8(0xaf), uint8(0xaf), uint8(0x6d), uint8(0x1f), uint8(0xd), uint8(0x98), uint8(0x9b), uint8(0xed)}
}

func (m *Initialize) Build() (solana.Instruction, error) {
	var generic solana.GenericInstruction
	generic.ProgID = m.ProgramID()
	generic.AccountValues = solana.AccountMetaSlice{{
		IsSigner:   true,
		IsWritable: true,
		PublicKey:  m.Accounts.Counter,
	}, {
		IsSigner:   true,
		IsWritable: true,
		PublicKey:  m.Accounts.User,
	}, {
		IsSigner:   false,
		IsWritable: false,
		PublicKey:  m.Accounts.SystemProgram,
	}}
	for _, item := range m.RemainingAccounts {
		generic.AccountValues = append(generic.AccountValues, item)
	}
	buf := bytes.Buffer{}
	buf.Write(m.Discriminator())
	enc := bin.NewBorshEncoder(&buf)
	err := enc.Encode(&m.Args)
	if err != nil {
		return nil, err
	}
	generic.DataBytes = buf.Bytes()
	return &generic, nil
}

func (m *Initialize) Decode(accounts []solana.PublicKey, data []byte) error {
	if len(accounts) < 3 {
		return fmt.Errorf("insufficient accounts, expect at least %d, but got %d", 3, len(accounts))
	}
	m.Accounts.Counter = accounts[0]
	m.Accounts.User = accounts[1]
	m.Accounts.SystemProgram = accounts[2]
	for _, item := range accounts[3:] {
		m.RemainingAccounts = append(m.RemainingAccounts, solana.Meta(item))
	}
	dec := bin.NewBorshDecoder(data[len(m.Discriminator()):])
	return dec.Decode(&m.Args)
}

func DecodeAnchorCounterInstructionRaw(accounts []*solana.AccountMeta, data []byte) (decoded any, ok bool, err error) {
	mappings := make([]solana.PublicKey, len(accounts))
	for i, item := range accounts {
		mappings[i] = item.PublicKey
	}
	return DecodeAnchorCounterInstruction(mappings, data)
}
func DecodeAnchorCounterInstruction(accounts []solana.PublicKey, data []byte) (decoded any, ok bool, err error) {
	if len(data) < 8 {
		return nil, false, fmt.Errorf("data length is less than 8 bytes")
	}
	discriminator := [8]byte(data[0:8])
	switch discriminator {
	case [8]byte{uint8(0xb), uint8(0x12), uint8(0x68), uint8(0x9), uint8(0x68), uint8(0xae), uint8(0x3b), uint8(0x21)}:
		var m = Increment{}
		err = m.Decode(accounts, data)
		return &m, true, err
	case [8]byte{uint8(0xaf), uint8(0xaf), uint8(0x6d), uint8(0x1f), uint8(0xd), uint8(0x98), uint8(0x9b), uint8(0xed)}:
		var m = Initialize{}
		err = m.Decode(accounts, data)
		return &m, true, err
	default:
		return nil, false, nil
	}
}

type Counter struct {
	Count uint64
}

func (m *Counter) Discriminator() []byte {
	return []byte{uint8(0xff), uint8(0xb0), uint8(0x4), uint8(0xf5), uint8(0xbc), uint8(0xfd), uint8(0x7c), uint8(0x19)}
}

func DecodeCounter(resp *rpc.GetAccountInfoResult) (*Counter, error) {
	var m Counter
	data := resp.GetBinary()
	if len(data) < len(m.Discriminator()) {
		return nil, fmt.Errorf("invalid response data")
	}
	discriminator := data[0:len(m.Discriminator())]
	if !bytes.Equal(discriminator, m.Discriminator()) {
		return nil, fmt.Errorf("discriminator mismatch, expect %x, but got %x", m.Discriminator(), discriminator)
	}
	dec := bin.NewBorshDecoder(data[len(m.Discriminator()):])
	err := dec.Decode(&m)
	return &m, err
}
